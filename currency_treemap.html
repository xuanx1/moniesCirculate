<!DOCTYPE html>
<html>
<head>
    <title>Ringgit in Circulation, Over the Years</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/d3@7.8.2"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-delaunay@6.0.2"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-weighted-voronoi@1.1.3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-voronoi-map@2.1.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-voronoi-treemap@1.1.2"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0;
            margin: 0;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        h1 {
            display: none;
        }

        .subtitle {
            color: rgba(0,0,0,0.6);
            text-align: center;
            margin-bottom: 5px;
            font-size: 12px;
            position: relative;
            z-index: 1000;
            background: transparent;
        }

        #toggleView {
            display: none;
        }

        .container {
            width: 100vw;
            height: 100vh;
            padding: 0;
            max-width: 100%;
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 0;
            margin: 0;
            position: fixed;
            top: 0;
            left: 0;
        }

        svg {
            display: block;
            margin: 0;
            width: 100vw;
            height: 100vh;
        }

        .drawingArea {
            font-family: "Segoe UI", sans-serif;
        }

        #title {
            font-size: 20px;
            font-weight: 600;
            fill: #333;
        }

        .world {
            fill: none;
            stroke: #ddd;
            stroke-width: 1;
        }

        .cell {
            stroke: white;
            stroke-width: 8;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .cell:hover {
            opacity: 0.8;
            stroke-width: 3;
        }

        .hoverer {
            fill: none;
            stroke: none;
            pointer-events: all;
            cursor: pointer;
        }

        .labels {
            pointer-events: none;
        }

        .label {
            text-anchor: middle;
        }

        .label text {
            font-weight: 600;
            fill: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .label .name {
            font-size: 14px;
            font-weight: 700;
        }

        .label .value {
            font-size: 12px;
            fill: rgba(255,255,255,0.9);
        }

        .legend {
            font-size: 12px;
        }

        .legend-color {
            stroke: #333;
            stroke-width: 1;
        }

        .legend text {
            font-size: 12px;
            fill: #333;
            font-weight: 500;
        }

        .tiny {
            font-size: 10px;
            fill: #999;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        svg {
            transition: opacity 0.3s ease;
        }

        svg.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .color-scale-1 { background: #e74c3c; }
        .color-scale-2 { background: #e67e22; }
        .color-scale-3 { background: #f39c12; }
        .color-scale-4 { background: #f1c40f; }
        .color-scale-5 { background: #2ecc71; }
        .color-scale-6 { background: #3498db; }
        .color-scale-7 { background: #9b59b6; }
        .color-scale-8 { background: #1abc9c; }

        .hover-tooltip {
            position: fixed;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #999;
            border-radius: 4px;
            padding: 12px;
            font-size: 12px;
            pointer-events: none;
            z-index: 2000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            max-width: 220px;
            font-family: 'Gotham', 'Helvetica Neue', sans-serif;
            overflow: hidden;
        }

        .tooltip-title {
            font-weight: 900;
            font-size: 16px;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #c06c84 0%, #f8b195 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: 1px;
        }

        .tooltip-value {
            margin-bottom: 8px;
            color: #666;
            font-size: 11px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 2px;
            overflow: hidden;
            border: 1px solid #999;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #c06c84 0%, #f8b195 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
            font-weight: bold;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <h1>Ringgit in Circulation, Over the Years</h1>
    <div class="container" id="voronoiContainer">
        <div class="loading">Loading data...</div>
        <svg id="voronoiSvg"></svg>
    </div>

    <script>
        // Constants
        const _2PI = 2 * Math.PI;

        // Function to convert denomination name to display label
        function getDenominationLabel(denomName) {
            const lowerName = denomName.toLowerCase();
            
            // Map coin denominations
            if (lowerName === 'coin_1') return '1 Cent';
            if (lowerName === 'coin_5') return '5 Cent';
            if (lowerName === 'coin_10') return '10 Cent';
            if (lowerName === 'coin_20') return '20 Cent';
            if (lowerName === 'coin_50') return '50 Cent';
            if (lowerName === 'coin_rm1') return '1 Ringgit';
            if (lowerName === 'coin_rm5') return '5 Ringgit';
            if (lowerName === 'coin_others') return 'Other Coins';
            
            // Map note denominations
            if (lowerName === 'note_1') return '1 Ringgit';
            if (lowerName === 'note_2') return '2 Ringgit';
            if (lowerName === 'note_5') return '5 Ringgit';
            if (lowerName === 'note_10') return '10 Ringgit';
            if (lowerName === 'note_20') return '20 Ringgit';
            if (lowerName === 'note_50') return '50 Ringgit';
            if (lowerName === 'note_100') return '100 Ringgit';
            if (lowerName === 'note_500') return '500 Ringgit';
            if (lowerName === 'note_1000') return '1000 Ringgit';
            if (lowerName === 'note_others') return 'Other Notes';
            
            // Fallback to original name
            return denomName;
        }

        // Function to calculate tooltip position keeping it within viewport
        function getTooltipPosition(mouseX, mouseY, tooltipWidth, tooltipHeight) {
            const offsetX = 10;
            const offsetY = 10;
            const padding = 5;
            let left = mouseX + offsetX;
            let top = mouseY + offsetY;
            
            // Check right boundary
            if (left + tooltipWidth + padding > window.innerWidth) {
                left = window.innerWidth - tooltipWidth - padding;
            }
            
            // Check bottom boundary
            if (top + tooltipHeight + padding > window.innerHeight) {
                top = window.innerHeight - tooltipHeight - padding;
            }
            
            // Ensure minimum position
            left = Math.max(padding, left);
            top = Math.max(padding, top);
            
            return { left, top };
        }

        // Layout configuration - DYNAMIC
        let svgWidth = window.innerWidth;
        let svgHeight = window.innerHeight;
        let margin = { top: 10, right: 10, bottom: 10, left: 10 };
        let height = svgHeight - margin.top - margin.bottom;
        let width = svgWidth - margin.left - margin.right;
        let halfWidth = width / 2;
        let halfHeight = height / 2;
        const titleY = 20;
        let legendsMinY = height - 20;
        const treemapRadius = 220;
        let treemapCenter = [halfWidth, halfHeight + 5];
        
        // Function to update dimensions on resize
        function updateDimensions() {
            svgWidth = window.innerWidth;
            svgHeight = window.innerHeight;
            height = svgHeight - margin.top - margin.bottom;
            width = svgWidth - margin.left - margin.right;
            halfWidth = width / 2;
            halfHeight = height / 2;
            legendsMinY = height - 20;
            treemapCenter = [halfWidth, halfHeight + 5];
            
            // Update SVG sizes if they exist
            if (svg) {
                svg.attr('width', svgWidth).attr('height', svgHeight);
            }
        }
        
        // Helper function to reorder polygon points for optimal morphing
        // Finds the best starting point to minimize morphing distance
        function optimizePolygonForMorphing(newPolygon, oldPolygon) {
            if (!oldPolygon || oldPolygon.length === 0) return newPolygon;
            if (newPolygon.length !== oldPolygon.length) return newPolygon;
            
            // Calculate centroid of old polygon
            const oldCentroid = [
                oldPolygon.reduce((sum, p) => sum + p[0], 0) / oldPolygon.length,
                oldPolygon.reduce((sum, p) => sum + p[1], 0) / oldPolygon.length
            ];
            
            // Find the point in the new polygon closest to the old centroid
            let bestIdx = 0;
            let bestDist = Infinity;
            
            newPolygon.forEach((point, idx) => {
                const dist = Math.pow(point[0] - oldCentroid[0], 2) + Math.pow(point[1] - oldCentroid[1], 2);
                if (dist < bestDist) {
                    bestDist = dist;
                    bestIdx = idx;
                }
            });
            
            // Rotate array to start from best index
            return [...newPolygon.slice(bestIdx), ...newPolygon.slice(0, bestIdx)];
        }
        
        // Helper function to get correct image path for denomination based on year
        function getNotePath(denom, year) {
            year = year || new Date().getFullYear();
            
            const imageMap = {
                '1': [
                    { years: [1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010], file: '1-malaysian-ringgit-3rd-series-obverse-1-1998-2000.jpg' },
                    { years: [2011, 2012, 2013, 2014, 2015, 2016,2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025], file: '1-malaysian-ringgit-4th-series-obverse-1-2011-2025.jpg' }
                ],
                '2': [
                    { years: [1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025], file: '2-malaysian-ringgit-3rd-series-obverse-1-1996-1999.jpg' }
                ],
                '5': [
                    { years: [1999, 2000, 2001, 2002, 2003], file: '5-malaysian-ringgit-3rd-series-obverse-5-1999-2001.jpg' },
                    { years: [2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011], file: '5-malaysian-ringgit-3rd-series-obverse-5-2004.jpg' },
                    { years: [2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025], file: '5-malaysian-ringgit-4th-series-obverse-5-2012-2025.jpg' }
                ],
                '10': [
                    { years: [1997, 1998, 1999, 2000, 2001, 2002, 2003], file: '10-malaysian-ringgit-3rd-series-obverse-10-1997-2001.jpg' },
                    { years: [2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011], file: '10-malaysian-ringgit-3rd-series-obverse-10-2004-2011.jpg' },
                    { years: [2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025], file: '10-malaysian-ringgit-4th-series-obverse-10-2012-2024.jpg' }
                ],
                '20': [
                    { years: [1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010], file: '20-malaysian-ringgit-2nd-series-obverse-20-1989.jpg' },
                    { years: [2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025], file: '20-malaysian-ringgit-4th-series-obverse-20-2011-2025.jpg' }
                ],
                '50': [
                    { years: [1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006], file: '50-malaysian-ringgit-3rd-series-obverse-50-1998-2001.jpg' },
                    { years: [2007, 2008], file: '50-malaysian-ringgit-4th-series-obverse-50-2007-2008-50th-Anniversary.jpg' },
                    { years: [2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025], file: '50-malaysian-ringgit-4th-series-obverse-50-2009-2024.jpg' }
                ],
                '100': [
                    { years: [1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011], file: '100-malaysian-ringgit-3rd-series-obverse-100-1998-2001.jpg' },
                    { years: [2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025], file: '100-malaysian-ringgit-4th-series-obverse-100-2012-2024.jpg' }
                ],
                '500': [
                    { years: [2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025], file: '500-malaysian-ringgit-obverse-1.jpg' }
                ],
                '1000': [
                    { years: [2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025], file: '1000-malaysian-ringgit-obverse-1.jpg' }
                ]
            };
            
            const variants = imageMap[denom];
            if (variants) {
                for (let variant of variants) {
                    if (variant.years.includes(year)) {
                        return `myr/${variant.file}`;
                    }
                }
                // Fallback to first available
                return `myr/${variants[0].file}`;
            }
            
            return `myr/${denom}-malaysian-ringgit-4th-series-obverse-1.jpg`;
        }

        function getNotePaths(denom, year) {
            year = year || new Date().getFullYear();
            
            const imageMap = {
                '1': [
                    { years: [1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010], obverse: '1-malaysian-ringgit-3rd-series-obverse-1-1998-2000.jpg', reverse: '1-malaysian-ringgit-3rd-series-reverse-1-1998-2000.jpg' },
                    { years: [2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025], obverse: '1-malaysian-ringgit-4th-series-obverse-1-2011-2025.jpg', reverse: '1-malaysian-ringgit-4th-series-reverse-1-2011-2025.jpg' }
                ],
                '2': [
                    { years: [1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025], obverse: '2-malaysian-ringgit-3rd-series-obverse-1-1996-1999.jpg', reverse: '2-malaysian-ringgit-3rd-series-reverse-1-1996-1999.jpg' }
                ],
                '5': [
                    { years: [1999, 2000, 2001, 2002, 2003], obverse: '5-malaysian-ringgit-3rd-series-obverse-5-1999-2001.jpg', reverse: '5-malaysian-ringgit-3rd-series-reverse-5-1999-2001.jpg' },
                    { years: [2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011], obverse: '5-malaysian-ringgit-3rd-series-obverse-5-2004.jpg', reverse: '5-malaysian-ringgit-3rd-series-reverse-5-2004.jpg' },
                    { years: [2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025], obverse: '5-malaysian-ringgit-4th-series-obverse-5-2012-2025.jpg', reverse: '5-malaysian-ringgit-4th-series-reverse-5-2012-2025.jpg' }
                ],
                '10': [
                    { years: [1997, 1998, 1999, 2000, 2001, 2002, 2003], obverse: '10-malaysian-ringgit-3rd-series-obverse-10-1997-2001.jpg', reverse: '10-malaysian-ringgit-3rd-series-reverse-10-1997-2001.jpg' },
                    { years: [2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011], obverse: '10-malaysian-ringgit-3rd-series-obverse-10-2004-2011.jpg', reverse: '10-malaysian-ringgit-3rd-series-reverse-10-2004-2011.jpg' },
                    { years: [2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025], obverse: '10-malaysian-ringgit-4th-series-obverse-10-2012-2024.jpg', reverse: '10-malaysian-ringgit-4th-series-reverse-10-2012-2024.jpg' }
                ],
                '20': [
                    { years: [1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010], obverse: '20-malaysian-ringgit-2nd-series-obverse-20-1989.jpg', reverse: '20-malaysian-ringgit-2nd-series-reverse-20-1989.jpg' },
                    { years: [2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025], obverse: '20-malaysian-ringgit-4th-series-obverse-20-2011-2025.jpg', reverse: '20-malaysian-ringgit-4th-series-reverse-20-2011-2025.jpg' }
                ],
                '50': [
                    { years: [1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006], obverse: '50-malaysian-ringgit-3rd-series-obverse-50-1998-2001.jpg', reverse: '50-malaysian-ringgit-3rd-series-reverse-50-1998-2001.jpg' },
                    { years: [2007, 2008], obverse: '50-malaysian-ringgit-4th-series-obverse-50-2007-2008-50th-Anniversary.jpg', reverse: '50-malaysian-ringgit-4th-series-reverse-50-2007-2008-50th-Anniversary.jpg' },
                    { years: [2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025], obverse: '50-malaysian-ringgit-4th-series-obverse-50-2009-2024.jpg', reverse: '50-malaysian-ringgit-4th-series-reverse-50-2009-2024.jpg' }
                ],
                '100': [
                    { years: [1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011], obverse: '100-malaysian-ringgit-3rd-series-obverse-100-1998-2001.jpg', reverse: '100-malaysian-ringgit-3rd-series-reverse-100-1998-2001.jpg' },
                    { years: [2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025], obverse: '100-malaysian-ringgit-4th-series-obverse-100-2012-2024.jpg', reverse: '100-malaysian-ringgit-4th-series-reverse-100-2012-2024.jpg' }
                ],
                '500': [
                    { years: [2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025], obverse: '500-malaysian-ringgit-obverse-1.jpg', reverse: '500-malaysian-ringgit-reverse-1.jpg' }
                ],
                '1000': [
                    { years: [2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025], obverse: '1000-malaysian-ringgit-obverse-1.jpg', reverse: '1000-malaysian-ringgit-reverse-1.jpg' }
                ]
            };
            
            const variants = imageMap[denom];
            if (variants) {
                for (let variant of variants) {
                    if (variant.years.includes(year)) {
                        return { obverse: `myr/${variant.obverse}`, reverse: `myr/${variant.reverse}` };
                    }
                }
                // Fallback to first available
                return { obverse: `myr/${variants[0].obverse}`, reverse: `myr/${variants[0].reverse}` };
            }
            
            return { obverse: `myr/${denom}-malaysian-ringgit-4th-series-obverse-1.jpg`, reverse: `myr/${denom}-malaysian-ringgit-4th-series-reverse-1.jpg` };
        }

        // Voronoi treemap configuration
        let voronoiTreemap, hierarchy, circlingPolygon;

        // Drawing configuration
        const fontScale = d3.scaleLinear().domain([3, 20]).range([8, 20]).clamp(true);
        const colorScale = d3.scaleOrdinal()
            .domain(['coin_1', 'coin_5', 'coin_10', 'coin_20', 'coin_50', 'coin_rm1', 'coin_rm5', 'coin_others', 'note_1', 'note_2', 'note_5', 'note_10', 'note_20', 'note_50', 'note_100', 'note_500', 'note_1000', 'note_others'])
            .range(['#e0e0e0', '#d0d0d0', '#bdbdbd', '#9e9e9e', '#757575', '#616161', '#424242', '#212121', '#c41c3b', '#d32f2f', '#e53935', '#ef5350', '#f44336', '#e74c3c', '#d81b60', '#a00850', '#880050', '#c41c3b']);

        // Reusable D3 selections
        let svg, drawingArea, treemapContainer;

        // Seeded random for consistent Voronoi layout
        function seededRandom(seed) {
            const x = Math.sin(seed) * 10000;
            return x - Math.floor(x);
        }
        
        let randomSeed = 9; // Fixed seed for consistent layout
        const deterministicRandom = () => {
            randomSeed = (randomSeed * 9301 + 49297) % 233280;
            return randomSeed / 233280;
        };

        // Initialize
        fetch('data/currency_in_circulation.csv')
            .then(response => response.text())
            .then(csvText => {
                const data = parseCSV(csvText);
                // Initialize voronoiTreemap after d3 libraries are loaded
                voronoiTreemap = d3.voronoiTreemap().prng(deterministicRandom);
                init(data);
            })
            .catch(error => {
                console.error('Error loading data:', error);
                document.querySelector('.loading').textContent = 'Error loading data. Please check the CSV file.';
            });
        
        // Handle window resize - FULL REBUILD
        window.addEventListener('resize', () => {
            updateDimensions();
            // Redraw if data is loaded
            if (window.allDates && window.dataByDate && hierarchy) {
                // Rebuild circling polygon with new dimensions
                circlingPolygon = computeCirclingPolygon(treemapRadius);
                treemapCenter = [halfWidth, halfHeight + 5];
                
                // Clear and rebuild visualization
                if (svg) {
                    // Clear all children except the SVG itself
                    svg.selectAll('*').remove();
                    
                    // Rebuild layout with new dimensions
                    initLayout(hierarchy.data);
                    
                    // Redraw current data
                    const currentIdx = window.timeline ? window.timeline.currentIdx : (window.allDates.length - 1);
                    const currentDate = window.allDates[currentIdx];
                    updateVoronoiForYear(currentDate, currentIdx);
                }
            }
        }, { passive: true });
        
        // Also update on every frame to catch rapid resizes
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (svg && window.timeline) {
                    // Ensure controls are positioned correctly
                    const controlsHeight = 70;
                    const controlWidth = Math.min(300, svgWidth * 0.4);
                    if (window.timeline.group) {
                        window.timeline.group.attr('transform', `translate(${svgWidth / 2 - controlWidth / 2},${svgHeight - controlsHeight})`);
                    }
                }
            }, 100);
        }, { passive: true });

        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n');
            const headers = lines[0].split(',');
            
            // Collect all dates and data
            const dataByDate = {};
            const monthlyTotals = {}; // For line chart - total
            const monthlyDenominations = {}; // For line chart - individual denominations
            const dates = new Set();
            const yearlyDates = new Set(); // Only January dates for Voronoi
            
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',');
                const date = values[0];
                const denomination = values[1];
                const value = parseFloat(values[2]);
                
                dates.add(date);
                
                // Collect total for monthly line chart
                if (denomination === 'total') {
                    monthlyTotals[date] = value;
                }
                
                // Collect denomination data for monthly line chart (skip coins and others)
                if (!denomination.includes('coin') && denomination !== 'total' && denomination !== 'note_others') {
                    if (!monthlyDenominations[denomination]) {
                        monthlyDenominations[denomination] = {};
                    }
                    monthlyDenominations[denomination][date] = value;
                }
                
                // Skip coins, total, and note_others for Voronoi treemap
                if (denomination.includes('coin') || denomination === 'total' || denomination === 'note_others') {
                    continue;
                }
                
                if (!dataByDate[date]) {
                    dataByDate[date] = {};
                }
                dataByDate[date][denomination] = value;
                
                // Track January dates only (yyyy-01-01)
                if (date.endsWith('-01-01')) {
                    yearlyDates.add(date);
                }
            }
            
            // Sort yearly dates (January only for Voronoi)
            const sortedYearlyDates = Array.from(yearlyDates).sort();
            
            // Sort all monthly dates for line chart
            const sortedMonthlyDates = Array.from(dates).sort();
            
            // Store globally
            window.allDates = sortedYearlyDates; // For Voronoi treemap (yearly)
            window.dataByDate = dataByDate;
            window.monthlyTotals = monthlyTotals; // For line chart - total
            window.monthlyDenominations = monthlyDenominations; // For line chart - denominations
            window.allMonthlyDates = sortedMonthlyDates; // For line chart x-axis
            
            // Return latest January date's data for initial load
            const lastDate = sortedYearlyDates[sortedYearlyDates.length - 1];
            
            const children = Object.entries(dataByDate[lastDate] || {})
                .sort((a, b) => a[0].localeCompare(b[0]))  // Alphabetical order for consistency
                .map(([name, value]) => ({
                    name: name,
                    weight: value,
                    color: colorScale(name)
                }));
            
            return {
                name: 'Currency',
                children: children,
                color: '#666'
            };
        }

        function init(rootData) {
            initData();
            initLayout(rootData);
            
            // Calculate total from the data
            const totalValue = rootData.children.reduce((sum, child) => sum + child.weight, 0);
            const displayValue = `RM ${(totalValue / 1000).toFixed(2)}B`;
            
            // Update stats text directly using the global reference
            try {
                if (window.statsValueTextPath) {
                    window.statsValueTextPath.text(displayValue);
                }
            } catch (e) {
                console.error('Error updating stats:', e);
            }
            
            // Reset random seed for consistent Voronoi layout
            randomSeed = 9;
            
            hierarchy = d3.hierarchy(rootData).sum(d => d.weight);
            voronoiTreemap.clip(circlingPolygon)(hierarchy);
            
            const year = parseInt(window.allDates[window.allDates.length - 1].split('-')[0]);
            drawTreemap(hierarchy, year);
            document.querySelector('.loading').remove();
        }

        function initData() {
            circlingPolygon = computeCirclingPolygon(treemapRadius);
        }

        function computeCirclingPolygon(radius) {
            const points = 60;
            const increment = _2PI / points;
            const circlingPolygon = [];
            
            for (let i = 0; i < points; i++) {
                const a = i * increment;
                circlingPolygon.push([
                    radius + radius * Math.cos(a),
                    radius + radius * Math.sin(a)
                ]);
            }
            
            return circlingPolygon;
        }

        function initLayout(rootData) {
            svg = d3.select('#voronoiSvg')
                .attr('width', svgWidth)
                .attr('height', svgHeight);
            
            drawingArea = svg.append('g')
                .classed('drawingArea', true)
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Set initial zoom to 1.3x centered on the screen
            const initialZoomTransform = d3.zoomIdentity
                .translate(svgWidth / 2, svgHeight / 2)
                .scale(1.3)
                .translate(-svgWidth / 2, -svgHeight / 2)
                .translate(margin.left, margin.top);
            
            // Add zoom behavior - but NOT on controls area
            let isResettingZoom = false;
            const zoom = d3.zoom()
                .scaleExtent([1.3, 8])  // Min zoom 1x, Max zoom 8x
                .on('zoom', (event) => {
                    // Don't zoom if click is on controls
                    if (event.sourceEvent && event.sourceEvent.target.closest('.controls-fixed')) {
                        return;
                    }
                    
                    // If zoomed out to minimum, reset to initial view (but prevent infinite loop)
                    if (event.transform.k <= 1.3 && !isResettingZoom) {
                        isResettingZoom = true;
                        svg.call(zoom.transform, initialZoomTransform);
                        isResettingZoom = false;
                    } else {
                        drawingArea.attr('transform', event.transform);
                    }
                });
            
            svg.call(zoom);
            
            svg.call(zoom.transform, initialZoomTransform);
            
            treemapContainer = drawingArea.append('g')
                .classed('treemap-container', true)
                .attr('transform', `translate(${treemapCenter})`);
            
            treemapContainer.append('path')
                .classed('world', true)
                .attr('transform', `translate(${-treemapRadius},${-treemapRadius})`)
                .attr('d', `M${circlingPolygon.join(',')}Z`);
            
            // Create title arc as part of the drawing area (moves with viz)
            // Add defs for text path in main SVG
            if (!svg.select('defs').size()) {
                svg.append('defs');
            }
            
            // Create circular arc path for title (top of circle with 20px offset)
            // Arc is relative to treemapCenter
            const titleRadius = treemapRadius + 20;
            const rotationOffset = -Math.PI * 20 / 180;  // clockwise rotation
            const arcStartAngle = -Math.PI * 120 / 180 + rotationOffset;
            const arcEndAngle = Math.PI * 40 / 180 + rotationOffset;
            
            const arcStart = [
                titleRadius * Math.cos(arcStartAngle),
                titleRadius * Math.sin(arcStartAngle)
            ];
            const arcEnd = [
                titleRadius * Math.cos(arcEndAngle),
                titleRadius * Math.sin(arcEndAngle)
            ];
            
            const largeArcFlag = 0;
            const sweepFlag = 1;
            
            const pathData = `M${arcStart[0]},${arcStart[1]} A${titleRadius},${titleRadius} 0 ${largeArcFlag} ${sweepFlag} ${arcEnd[0]},${arcEnd[1]}`;
            
            svg.select('defs').append('path')
                .attr('id', 'titleArc')
                .attr('d', pathData)
                .style('fill', 'none');
            
            // Create text that follows the arc - add to treemapContainer so it moves with viz
            const titleText = treemapContainer.append('text')
                .style('font-size', '24px')
                .style('fill', 'url(#gradientText)')
                .style('font-weight', '700')
                .style('font-family', 'Gotham, "Helvetica Neue", sans-serif')
                .style('pointer-events', 'none')
                .style('letter-spacing', '2px');
            
            const titleTextPath = titleText.append('textPath')
                .attr('href', '#titleArc')
                .attr('startOffset', '50%')
                .attr('text-anchor', 'middle')
                .text('2025 - Ringgit in Circulation, Over the Years');
            
            // Store reference for updating year during timeline scrubbing
            window.titleTextPath = titleTextPath;
            
            // Create counterclockwise arc for stats (same path as title but reversed direction)
            const statsRadius = treemapRadius + 25;
            const statsRotationOffset = -Math.PI * 150 / 180;  // Same rotation as title
            const statsArcStartAngle = Math.PI * 40 / 180 + statsRotationOffset;  // Reversed: end becomes start
            const statsArcEndAngle = -Math.PI * 120 / 180 + statsRotationOffset;  // Reversed: start becomes end
            
            const statsArcStart = [
                statsRadius * Math.cos(statsArcStartAngle),
                statsRadius * Math.sin(statsArcStartAngle)
            ];
            const statsArcEnd = [
                statsRadius * Math.cos(statsArcEndAngle),
                statsRadius * Math.sin(statsArcEndAngle)
            ];
            
            const statsLargeArcFlag = 0;
            const statsSweepFlag = 0;  // 0 for counterclockwise
            
            const statsPathData = `M${statsArcStart[0]},${statsArcStart[1]} A${statsRadius},${statsRadius} 0 ${statsLargeArcFlag} ${statsSweepFlag} ${statsArcEnd[0]},${statsArcEnd[1]}`;
            
            svg.select('defs').append('path')
                .attr('id', 'statsArc')
                .attr('d', statsPathData)
                .style('fill', 'none');
            
            // Create text that follows the stats arc (counterclockwise at bottom)
            const statsText = treemapContainer.append('text')
                .style('font-size', '10px')
                .style('fill', '#333')
                .style('font-weight', '700')
                .style('font-family', 'Gotham, "Helvetica Neue", sans-serif')
                .style('pointer-events', 'none')
                .style('letter-spacing', '1.5px')
                .style('z-index', '2001');
            
            const statsTextPath = statsText.append('textPath')
                .attr('href', '#statsArc')
                .attr('startOffset', '50%')
                .attr('text-anchor', 'middle')
                .text('TOTAL IN CIRCULATION');
            
            // Create stats value - gradient colored on arc
            const statsValueText = treemapContainer.append('text')
                .style('font-size', '20px')
                .style('fill', 'url(#gradientText)')
                .style('font-weight', '700')
                .style('font-family', 'Gotham, "Helvetica Neue", sans-serif')
                .style('pointer-events', 'none')
                .style('z-index', '2001');
            
            const statsValueTextPath = statsValueText.append('textPath')
                .attr('href', '#statsArc')
                .attr('startOffset', '63%')
                .attr('text-anchor', 'start')
                .text('RM 0.00B');
            
            // Store stats references for later updates
            window.statsTextPath = statsTextPath;
            window.statsValueTextPath = statsValueTextPath;
            
            // Add gradient definition for text
            svg.select('defs').append('linearGradient')
                .attr('id', 'gradientText')
                .attr('x1', '0%')
                .attr('x2', '100%')
                .attr('y1', '0%')
                .attr('y2', '0%')
                .append('stop')
                .attr('offset', '0%')
                .attr('stop-color', '#c06c84');
            
            svg.select('#gradientText').append('stop')
                .attr('offset', '100%')
                .attr('stop-color', '#f8b195');
            
            // Add gradient definition for timeline
            svg.select('defs').append('linearGradient')
                .attr('id', 'timelineGradient')
                .attr('x1', '0%')
                .attr('x2', '100%')
                .attr('y1', '0%')
                .attr('y2', '0%')
                .append('stop')
                .attr('offset', '0%')
                .attr('stop-color', '#c06c84');
            
            svg.select('#timelineGradient').append('stop')
                .attr('offset', '100%')
                .attr('stop-color', '#f8b195');
            
            // Create line chart below stats panel

            // Create video-style controls at bottom center
            const controlsHeight = 70;
            const controlWidth = Math.min(300, svgWidth * 0.4);
            const controlsGroup = svg.append('g')
                .classed('controls-fixed', true)
                .attr('transform', `translate(${svgWidth / 2 - controlWidth / 2},${svgHeight - controlsHeight + 7})`);
            
            // Controls background - removed for transparent look
            // controlsGroup.append('rect')
            //     .attr('width', controlWidth)
            //     .attr('height', controlsHeight)
            //     .style('fill', 'rgba(255, 255, 255, 0.95)')
            //     .style('stroke', '#999')
            //     .style('stroke-width', '2')
            //     .attr('rx', 4)
            
            // Play/Pause toggle button - transparent background, clickable, centered vertically with progress bar
            const playPauseButton = controlsGroup.append('rect')
                .attr('x', 15)
                .attr('y', 12)
                .attr('width', 24)
                .attr('height', 24)
                .attr('rx', 2)
                .style('fill', 'rgba(0, 0, 0, 0)')
                .style('cursor', 'pointer')
                .style('stroke', 'none')
                .style('stroke-width', '0')
                .style('pointer-events', 'auto');
            
            // Play triangle icon (will change to pause bars when playing)
            const playIcon = controlsGroup.append('polygon')
                .attr('points', '22,16 22,34 32,25')
                .style('fill', 'url(#timelineGradient)')
                .style('pointer-events', 'none');
            
            // Pause icon (bars - hidden initially)
            const pauseBar1 = controlsGroup.append('rect')
                .attr('x', 20)
                .attr('y', 16)
                .attr('width', 3)
                .attr('height', 18)
                .style('fill', 'url(#timelineGradient)')
                .style('pointer-events', 'none')
                .style('display', 'none');
            
            const pauseBar2 = controlsGroup.append('rect')
                .attr('x', 26)
                .attr('y', 16)
                .attr('width', 3)
                .attr('height', 18)
                .style('fill', 'url(#timelineGradient)')
                .style('pointer-events', 'none')
                .style('display', 'none');
            
            // Timeline background - shortened by 10%
            const timelineWidth = (controlWidth - 55) * 0.9;
            controlsGroup.append('rect')
                .attr('x', 45)
                .attr('y', 22)
                .attr('width', timelineWidth)
                .attr('height', 8)
                .attr('rx', 2)
                .style('fill', '#e0e0e0')
                .style('cursor', 'pointer')
                .style('border', '1px solid #999');
            
            // Timeline progress fill
            const timelineProgress = controlsGroup.append('rect')
                .attr('x', 45)
                .attr('y', 22)
                .attr('width', 0)
                .attr('height', 8)
                .attr('rx', 2)
                .style('fill', 'url(#timelineGradient)');
            
            // Store timeline references and animation state
            window.timeline = {
                group: controlsGroup,
                progress: timelineProgress,
                width: timelineWidth,
                isPlaying: false,
                currentIdx: window.allDates.length - 1,
                playPauseButton: playPauseButton,
                playIcon: playIcon,
                pauseBar1: pauseBar1,
                pauseBar2: pauseBar2
            };
            
            // Play/Pause toggle button click handler
            playPauseButton.on('click', function(event) {
                event.stopPropagation();
                window.timeline.isPlaying = !window.timeline.isPlaying;
                
                if (window.timeline.isPlaying) {
                    // Show pause icon, hide play icon
                    playIcon.style('display', 'none');
                    pauseBar1.style('display', 'block');
                    pauseBar2.style('display', 'block');
                    animateTimeline();
                } else {
                    // Show play icon, hide pause icon
                    playIcon.style('display', 'block');
                    pauseBar1.style('display', 'none');
                    pauseBar2.style('display', 'none');
                }
            });
            
            // Timeline scrubbing interaction - only on timeline bar area
            controlsGroup.on('click', function(event) {
                const rect = controlsGroup.node().getBoundingClientRect();
                const clickX = event.clientX - rect.left;
                
                // Only scrub if click is on the timeline bar (x >= 45)
                if (clickX >= 45) {
                    window.timeline.isPlaying = false;
                    playIcon.style('display', 'block');
                    pauseBar1.style('display', 'none');
                    pauseBar2.style('display', 'none');
                }
            });
            
            // Helper function to update timeline from click/drag position
            function updateTimelineFromPosition(clientX) {
                const rect = controlsGroup.node().getBoundingClientRect();
                const clickX = clientX - rect.left;
                
                // Only scrub if click is on the timeline bar (x >= 45)
                if (clickX >= 45) {
                    window.timeline.isPlaying = false;
                    playIcon.style('display', 'block');
                    pauseBar1.style('display', 'none');
                    pauseBar2.style('display', 'none');
                    const x = clickX - 45;
                    const ratio = Math.max(0, Math.min(1, x / timelineWidth));
                    const dateIdx = Math.round(ratio * (window.allDates.length - 1));
                    updateVoronoiForYear(window.allDates[dateIdx], dateIdx);
                }
            }
            
            // Timeline scrubbing interaction - click only (no drag)
            const timelineBar = controlsGroup.on('click', function(event) {
                updateTimelineFromPosition(event.clientX);
            });
            
            // Timeline scrubbing interaction - proper drag with mousedown check
            let isDraggingTimeline = false;
            
            controlsGroup.on('mousedown', function(event) {
                const rect = controlsGroup.node().getBoundingClientRect();
                const clickX = event.clientX - rect.left;
                if (clickX >= 45) {
                    isDraggingTimeline = true;
                    event.preventDefault();
                }
            });
            
            // Use D3's drag behavior for better control
            const dragHandler = d3.drag()
                .on('start', function() {
                    isDraggingTimeline = true;
                })
                .on('drag', function(event) {
                    if (isDraggingTimeline) {
                        updateTimelineFromPosition(event.sourceEvent.clientX);
                    }
                })
                .on('end', function() {
                    isDraggingTimeline = false;
                });
            
            controlsGroup.call(dragHandler);
            
            // Legend removed - now showing note previews in hover tooltips
        }



        function animateTimeline() {
            if (!window.timeline.isPlaying) return;
            
            window.timeline.currentIdx += 1;
            if (window.timeline.currentIdx >= window.allDates.length) {
                window.timeline.currentIdx = 0;
            }
            
            updateVoronoiForYear(window.allDates[window.timeline.currentIdx], window.timeline.currentIdx);
            
            // Continue animation after morphing completes (1200ms) + 300ms pause between years
            setTimeout(animateTimeline, 1500);
        }

        function updateVoronoiForYear(date, dateIdx) {
            if (!window.dataByDate[date]) {
                console.error('No data for date:', date);
                return;
            }
            
            // Track current index for animation
            window.timeline.currentIdx = dateIdx;
            
            // Update timeline progress
            const ratio = dateIdx / (window.allDates.length - 1);
            window.timeline.progress.attr('width', window.timeline.width * ratio);
            
            // Extract year from date
            const year = parseInt(date.split('-')[0]);
            
            // Update title with year
            if (window.titleTextPath) {
                window.titleTextPath.text(`${year} - Ringgit in Circulation, Over the Years`);
            }
            
            // Create new hierarchy for this date with consistent ordering
            // Sort by denomination name to ensure same layout every year
            const children = Object.entries(window.dataByDate[date])
                .sort((a, b) => a[0].localeCompare(b[0]))  // Alphabetical order for consistency
                .map(([name, value]) => ({
                    name: name,
                    weight: parseFloat(value),
                    color: colorScale(name)
                }));
            
            console.log('Date:', date, 'Children:', children, 'Data entry:', window.dataByDate[date]);
            
            // Update stats if it exists (only in treemap view)
            if (window.statsValueTextPath) {
                const totalValue = children.reduce((sum, child) => {
                    return sum + child.weight;
                }, 0);
                console.log('Total value for stats:', totalValue, 'Display:', `RM ${(totalValue / 1000).toFixed(2)}B`);
                window.statsValueTextPath.text(`RM ${(totalValue / 1000).toFixed(2)}B`);
            }
            
            const newData = {
                name: 'Currency',
                children: children,
                color: '#666'
            };
            
            // Reset random seed for consistent Voronoi layout across all years
            randomSeed = 9;
            
            // Recompute Voronoi treemap
            const newHierarchy = d3.hierarchy(newData).sum(d => d.weight);
            voronoiTreemap.clip(circlingPolygon)(newHierarchy);
            
            const newLeaves = newHierarchy.leaves();
            
            // Animate cell morphing with smooth transitions
            const transitionDuration = 1200; // ms (slowed down for better visibility)
            
            // Update existing cell paths with morphing animation
            const cells = treemapContainer.select('.cells');
            
            // Rebind cell groups with new data using denomination name as key
            const cellGroups = cells.selectAll('.cell')
                .data(newLeaves, (d) => d.data.name);
            
            // Animate fill path transitions with optimized morphing
            cellGroups.select('path')
                .transition()
                .duration(transitionDuration)
                .attrTween('d', function(d) {
                    // Get the old polygon from the current element
                    const oldPathData = d3.select(this).attr('d');
                    const oldPolygon = d.__oldPolygon || [];
                    
                    // Optimize new polygon point order for nearest-path morphing
                    const optimizedPolygon = optimizePolygonForMorphing(d.polygon, oldPolygon);
                    
                    // Store optimized polygon for next transition
                    d.__oldPolygon = optimizedPolygon;
                    
                    // Create path generator
                    const pathGen = (points) => `M${points.join(',')}z`;
                    
                    // Linear interpolator for smooth morphing
                    return (t) => {
                        const morphed = oldPolygon.map((oldPt, i) => [
                            oldPt[0] + (optimizedPolygon[i][0] - oldPt[0]) * t,
                            oldPt[1] + (optimizedPolygon[i][1] - oldPt[1]) * t
                        ]);
                        return pathGen(morphed);
                    };
                })
                .style('fill', d => d.data.color)
                .style('stroke', 'white')
                .style('stroke-width', 8)
                .style('stroke-linejoin', 'round')
                .style('stroke-linecap', 'round');
            
            // Update clipping paths to match morphing cells
            // Use main SVG defs (not treemapContainer) since clips must be in root
            const defs = svg.select('defs');
            newLeaves.forEach((d, idx) => {
                const clipPathId = window.clipPathMap[d.data.name] || `clip-${idx}`;
                let clipPath = defs.select(`#${clipPathId}`);
                
                // Create clip path if it doesn't exist
                if (clipPath.empty()) {
                    clipPath = defs.append('clipPath').attr('id', clipPathId);
                    clipPath.append('path');
                    window.clipPathMap[d.data.name] = clipPathId;
                }
                
                // Animate the clipping path with optimized morphing
                clipPath.select('path')
                    .transition()
                    .duration(transitionDuration)
                    .attrTween('d', function() {
                        const oldPolygon = d.__oldPolygon || [];
                        const optimizedPolygon = optimizePolygonForMorphing(d.polygon, oldPolygon);
                        
                        return (t) => {
                            const morphed = oldPolygon.map((oldPt, i) => [
                                oldPt[0] + (optimizedPolygon[i][0] - oldPt[0]) * t,
                                oldPt[1] + (optimizedPolygon[i][1] - oldPt[1]) * t
                            ]);
                            return `M${morphed.join(',')}z`;
                        };
                    });
            });
            
            // Update images with smooth transitions (morphing)
            // Get the images layer
            const imagesLayer = treemapContainer.select('.images-layer');
            
            // Update images for each denomination
            newLeaves.forEach((d) => {
                const isNote = d.data.name.toLowerCase().includes('note');
                
                if (isNote) {
                    const denomMatch = d.data.name.match(/\d+/);
                    if (denomMatch) {
                        const denom = denomMatch[0];
                        const imagePath = getNotePath(denom, year);
                        
                        const xs = d.polygon.map(p => p[0]);
                        const ys = d.polygon.map(p => p[1]);
                        const minX = Math.min(...xs);
                        const maxX = Math.max(...xs);
                        const minY = Math.min(...ys);
                        const maxY = Math.max(...ys);
                        const cellWidth = maxX - minX;
                        const cellHeight = maxY - minY;
                        
                        const imageAspectRatio = 1.5;
                        const cellAspectRatio = cellWidth / cellHeight;
                        
                        let scaledWidth, scaledHeight;
                        if (cellAspectRatio > imageAspectRatio) {
                            scaledWidth = cellWidth * 1.45;
                            scaledHeight = scaledWidth / imageAspectRatio;
                        } else {
                            scaledHeight = cellHeight * 1.45;
                            scaledWidth = scaledHeight * imageAspectRatio;
                        }
                        
                        const offsetX = (scaledWidth - cellWidth) / 2;
                        const offsetY = (scaledHeight - cellHeight) / 2;
                        const newX = minX - offsetX * 0.7;
                        const newY = minY - offsetY;
                        
                        // Find and update existing image for this denomination
                        const imageElement = imagesLayer.select(`image[data-denom="${d.data.name}"]`);
                        
                        // Set non-interpolatable attributes first (outside transition)
                        imageElement
                            .attr('xlink:href', imagePath)
                            .attr('href', imagePath)
                            .attr('clip-path', `url(#${window.clipPathMap[d.data.name]})`);
                        
                        // Then transition the position/size attributes
                        imageElement
                            .transition()
                            .duration(transitionDuration)
                            .attr('x', newX)
                            .attr('y', newY)
                            .attr('width', scaledWidth)
                            .attr('height', scaledHeight)
                            .style('pointer-events', 'none');
                    }
                }
            });
            
            // Update hoverers to match morphed cells
            const hoverers = treemapContainer.select('.hoverers');
            const hovererPaths = hoverers.selectAll('.hoverer')
                .data(newLeaves, (d) => d.data.name);
            
            hovererPaths.transition()
                .duration(transitionDuration)
                .attr('d', d => `M${d.polygon.join(',')}z`);
            
            // Update hover event handlers with new data
            hovererPaths.on('mouseenter', function(event, d) {
                // Calculate total value for percentage
                const totalValue = newLeaves.reduce((sum, leaf) => sum + leaf.value, 0);
                const percentage = (d.value / totalValue) * 100;
                
                // Create tooltip
                let tooltip = d3.select('body').select('.hover-tooltip');
                if (tooltip.empty()) {
                    tooltip = d3.select('body').append('div')
                        .classed('hover-tooltip', true);
                }
                
                // Check if it's a note and add image preview
                const isNote = d.data.name.toLowerCase().includes('note');
                let imageHtml = '';
                if (isNote) {
                    const denomMatch = d.data.name.match(/\d+/);
                    if (denomMatch) {
                        const paths = getNotePaths(denomMatch[0], year);
                        imageHtml = `
                            <div style="display: flex; flex-direction: column; align-items: center; gap: 6px; margin-bottom: 12px;">
                                <div style="text-align: center;">
                                    <img src="${paths.obverse}" style="width: 240px; height: auto; object-fit: contain; border: 2px solid #999; box-shadow: 0 2px 4px rgba(0,0,0,0.2);" />
                                    <div style="font-size: 10px; color: #666; margin-top: 4px;">Obverse</div>
                                </div>
                                <div style="text-align: center;">
                                    <img src="${paths.reverse}" style="width: 240px; height: auto; object-fit: contain; border: 2px solid #999; box-shadow: 0 2px 4px rgba(0,0,0,0.2);" />
                                    <div style="font-size: 10px; color: #666; margin-top: 4px;">Reverse</div>
                                </div>
                            </div>
                        `;
                    }
                }
                
                // Get monthly data for this denomination in this year (all months for that year)
                let monthlyDataHtml = '';
                if (window.monthlyDenominations && window.monthlyDenominations[d.data.name] && window.allMonthlyDates) {
                    const monthlyData = window.monthlyDenominations[d.data.name];
                    const yearStart = `${year}-`;
                    const yearMonths = window.allMonthlyDates.filter(date => date.startsWith(yearStart));
                    
                    if (yearMonths.length > 0) {
                        const yearValues = yearMonths
                            .map(date => monthlyData[date])
                            .filter(val => val !== undefined);
                        
                        if (yearValues.length > 0) {
                            // Create SVG line chart for monthly trend
                            const chartWidth = 180;
                            const chartHeight = 60;
                            const padding = { top: 8, right: 8, bottom: 15, left: 30 };
                            
                            const minVal = Math.min(...yearValues);
                            const maxVal = Math.max(...yearValues);
                            const range = maxVal - minVal || maxVal;
                            
                            // Calculate x and y positions for line chart
                            const pointCount = yearValues.length;
                            const xStep = (chartWidth - padding.left - padding.right) / (pointCount - 1 || 1);
                            const points = yearValues.map((val, i) => {
                                const x = padding.left + (i * xStep);
                                const y = chartHeight - padding.bottom - ((val - minVal) / range) * (chartHeight - padding.top - padding.bottom);
                                return `${x},${y}`;
                            }).join(' ');
                            
                            monthlyDataHtml = `
                                <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #ddd; width: 100%; overflow: hidden;">
                                    <div style="font-size: 10px; font-weight: 700; color: #333; margin-bottom: 4px;">${year} Monthly Trend</div>
                                    <svg width="100%" height="auto" viewBox="0 0 ${chartWidth} ${chartHeight}" preserveAspectRatio="xMidYMid meet" style="border: 1px solid #ddd; border-radius: 2px; background: #fafafa; max-width: 100%; max-height: 60px; display: block;">
                                        <!-- Y-axis -->
                                        <line x1="${padding.left}" y1="${padding.top}" x2="${padding.left}" y2="${chartHeight - padding.bottom}" stroke="#ddd" stroke-width="1"/>
                                        <!-- X-axis -->
                                        <line x1="${padding.left}" y1="${chartHeight - padding.bottom}" x2="${chartWidth - padding.right}" y2="${chartHeight - padding.bottom}" stroke="#ddd" stroke-width="1"/>
                                        <!-- Line chart -->
                                        <polyline points="${points}" fill="none" stroke="url(#gradientText)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                        <!-- Y-axis labels -->
                                        <text x="5" y="${chartHeight - padding.bottom + 3}" font-size="8" fill="#999" text-anchor="end">RM ${minVal.toFixed(0)}</text>
                                        <text x="5" y="${padding.top + 3}" font-size="8" fill="#999" text-anchor="end">RM ${maxVal.toFixed(0)}</text>
                                    </svg>
                                </div>
                            `;
                        }
                    }
                }
                
                tooltip.html(`
                    ${imageHtml}
                    <div class="tooltip-title">${getDenominationLabel(d.data.name)}</div>
                    <div class="tooltip-value">Circulating Value: RM ${d.value.toFixed(0)}</div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${percentage}%">
                            ${percentage.toFixed(1)}%
                        </div>
                    </div>
                    ${monthlyDataHtml}
                `)
                .style('opacity', 1);
                
                // Calculate position after content is rendered
                setTimeout(() => {
                    const tooltipNode = tooltip.node();
                    const tooltipWidth = tooltipNode.offsetWidth;
                    const tooltipHeight = tooltipNode.offsetHeight;
                    const pos = getTooltipPosition(event.pageX, event.pageY, tooltipWidth, tooltipHeight);
                    tooltip.style('left', pos.left + 'px')
                        .style('top', pos.top + 'px');
                }, 0);
            })
            .on('mousemove', function(event) {
                const tooltip = d3.select('.hover-tooltip');
                const tooltipNode = tooltip.node();
                if (tooltipNode) {
                    const tooltipWidth = tooltipNode.offsetWidth;
                    const tooltipHeight = tooltipNode.offsetHeight;
                    const pos = getTooltipPosition(event.pageX, event.pageY, tooltipWidth, tooltipHeight);
                    tooltip.style('left', pos.left + 'px')
                        .style('top', pos.top + 'px');
                }
            })
            .on('mouseleave', function(event, d) {
                d3.select('.hover-tooltip').style('opacity', 0);
            });
            
            // Update outlines layer to match morphed cells
            const outlinesLayer = treemapContainer.select('.outlines-layer');
            
            // Update each outline path by denomination
            newLeaves.forEach((d) => {
                const outlinePath = outlinesLayer.select(`path[data-denom="${d.data.name}"]`);
                
                if (!outlinePath.empty()) {
                    outlinePath.transition()
                        .duration(transitionDuration)
                        .attr('d', `M${d.polygon.join(',')}z`)
                        .style('stroke', 'white')
                        .style('stroke-width', 8)
                        .style('stroke-linejoin', 'round')
                        .style('stroke-linecap', 'round');
                }
            });
            
            // Legend is only created once in initLayout, don't recreate it here
        }

        function drawTreemap(hierarchy, year) {
            const leaves = hierarchy.leaves();
            
            // Create defs for clipping paths (append to main SVG, not to g element)
            const defs = svg.append('defs');
            
            // Create clipping paths for each cell using denomination name as ID
            leaves.forEach((d, idx) => {
                const clipPathId = `clip-${idx}`;
                const clipPath = defs.append('clipPath')
                    .attr('id', clipPathId);
                
                clipPath.append('path')
                    .attr('d', `M${d.polygon.join(',')}z`)
                    .attr('fill-rule', 'evenodd');
                
                // Store the clipPathId in the data for reference
                d.clipPathId = clipPathId;
            });
            
            // Also store mapping by denomination name for updateVoronoiForYear
            window.clipPathMap = {};
            leaves.forEach((d, idx) => {
                window.clipPathMap[d.data.name] = `clip-${idx}`;
            });
            
            // Draw cells (Voronoi regions)
            const cells = treemapContainer.append('g')
                .classed('cells', true)
                .attr('transform', `translate(${-treemapRadius},${-treemapRadius})`);
            
            const cellGroups = cells.selectAll('.cell')
                .data(leaves)
                .enter()
                .append('g')
                .classed('cell', true);
            
            // Add background color (fill only, no stroke here)
            cellGroups.append('path')
                .attr('d', d => `M${d.polygon.join(',')}z`)
                .style('fill', d => d.data.color)
                .style('pointer-events', 'none');
            
            // Create separate images layer on top (added AFTER cells for proper z-ordering)
            const imagesLayer = treemapContainer.append('g')
                .classed('images-layer', true)
                .attr('transform', `translate(${-treemapRadius},${-treemapRadius})`);
            
            // Add images for notes to the images layer
            leaves.forEach((d) => {
                const isNote = d.data.name.toLowerCase().includes('note');
                
                if (isNote) {
                    // Extract denomination number
                    const denomMatch = d.data.name.match(/\d+/);
                    if (denomMatch) {
                        const denom = denomMatch[0];
                        const imagePath = getNotePath(denom, year);
                        
                        // Calculate bounds of polygon
                        const xs = d.polygon.map(p => p[0]);
                        const ys = d.polygon.map(p => p[1]);
                        const minX = Math.min(...xs);
                        const maxX = Math.max(...xs);
                        const minY = Math.min(...ys);
                        const maxY = Math.max(...ys);
                        const cellWidth = maxX - minX;
                        const cellHeight = maxY - minY;
                        
                        // Image aspect ratio (typical note is landscape, ~1.5:1)
                        const imageAspectRatio = 1.5;
                        const cellAspectRatio = cellWidth / cellHeight;
                        
                        // Scale to cover entire cell completely (no gaps)
                        let scaledWidth, scaledHeight;
                        if (cellAspectRatio > imageAspectRatio) {
                            // Cell is wider than image, scale by width with extra padding
                            scaledWidth = cellWidth * 1.45;
                            scaledHeight = scaledWidth / imageAspectRatio;
                        } else {
                            // Cell is taller than image, scale by height with extra padding
                            scaledHeight = cellHeight * 1.45;
                            scaledWidth = scaledHeight * imageAspectRatio;
                        }
                        
                        const offsetX = (scaledWidth - cellWidth) / 2;
                        const offsetY = (scaledHeight - cellHeight) / 2;
                        
                        imagesLayer.append('image')
                            .attr('data-denom', d.data.name)
                            .attr('xlink:href', imagePath)
                            .attr('href', imagePath)
                            .attr('x', minX - offsetX * 0.9)
                            .attr('y', minY - offsetY)
                            .attr('width', scaledWidth)
                            .attr('height', scaledHeight)
                            .attr('clip-path', `url(#${d.clipPathId})`)
                            .attr('preserveAspectRatio', 'xMidYMid slice')
                            .style('pointer-events', 'none');
                    }
                }
            });
            
            // Create outlines layer on top of images (white strokes for cell boundaries)
            const outlinesLayer = treemapContainer.append('g')
                .classed('outlines-layer', true)
                .attr('transform', `translate(${-treemapRadius},${-treemapRadius})`);
            
            // Add white outline strokes for each cell
            leaves.forEach((d) => {
                outlinesLayer.append('path')
                    .attr('data-denom', d.data.name)
                    .attr('d', `M${d.polygon.join(',')}z`)
                    .style('fill', 'none')
                    .style('stroke', 'white')
                    .style('stroke-width', 5)
                    .style('stroke-linejoin', 'round')
                    .style('stroke-linecap', 'round')
                    .style('pointer-events', 'none');
            });
            
            // Draw labels (hidden by default, shown on hover)
            const labels = treemapContainer.append('g')
                .classed('labels', true)
                .attr('transform', `translate(${-treemapRadius},${-treemapRadius})`)
                .selectAll('.label')
                .data(leaves)
                .enter()
                .append('g')
                .classed('label', true)
                .attr('transform', d => `translate(${d.polygon.site.x},${d.polygon.site.y})`)
                .style('opacity', 0)
                .style('pointer-events', 'none')
                .style('transition', 'opacity 0.2s');
            
            labels.append('text')
                .classed('name', true)
                .text(d => d.data.name);
            
            labels.append('text')
                .classed('value', true)
                .attr('dy', '1.5em')
                .text(d => `RM ${d.value.toFixed(0)}`);
            
            // Draw hoverers
            const hoverers = treemapContainer.append('g')
                .classed('hoverers', true)
                .attr('transform', `translate(${-treemapRadius},${-treemapRadius})`)
                .selectAll('.hoverer')
                .data(leaves)
                .enter()
                .append('path')
                .classed('hoverer', true)
                .attr('d', d => `M${d.polygon.join(',')}z`)
                .style('cursor', 'pointer')
                .on('mouseenter', function(event, d) {
                    // Calculate total value for percentage
                    const totalValue = leaves.reduce((sum, leaf) => sum + leaf.value, 0);
                    const percentage = (d.value / totalValue) * 100;
                    
                    // Create tooltip
                    let tooltip = d3.select('body').select('.hover-tooltip');
                    if (tooltip.empty()) {
                        tooltip = d3.select('body').append('div')
                            .classed('hover-tooltip', true);
                    }
                    
                    // Check if it's a note and add image preview
                    const isNote = d.data.name.toLowerCase().includes('note');
                    let imageHtml = '';
                    if (isNote) {
                        const denomMatch = d.data.name.match(/\d+/);
                        if (denomMatch) {
                            const paths = getNotePaths(denomMatch[0], year);
                            imageHtml = `
                                <div style="display: flex; flex-direction: column; align-items: center; gap: 6px; margin-bottom: 12px;">
                                    <div style="text-align: center;">
                                        <img src="${paths.obverse}" style="width: 240px; height: auto; object-fit: contain; border: 2px solid #999; box-shadow: 0 2px 4px rgba(0,0,0,0.2);" />
                                        <div style="font-size: 10px; color: #666; margin-top: 4px;">Obverse</div>
                                    </div>
                                    <div style="text-align: center;">
                                        <img src="${paths.reverse}" style="width: 240px; height: auto; object-fit: contain; border: 2px solid #999; box-shadow: 0 2px 4px rgba(0,0,0,0.2);" />
                                        <div style="font-size: 10px; color: #666; margin-top: 4px;">Reverse</div>
                                    </div>
                                </div>
                            `;
                        }
                    }
                    
                    // Get monthly data for this denomination in this year (all months for that year)
                    let monthlyDataHtml = '';
                    if (window.monthlyDenominations && window.monthlyDenominations[d.data.name] && window.allMonthlyDates) {
                        const monthlyData = window.monthlyDenominations[d.data.name];
                        const yearStart = `${year}-`;
                        const yearMonths = window.allMonthlyDates.filter(date => date.startsWith(yearStart));
                        
                        if (yearMonths.length > 0) {
                            const yearValues = yearMonths
                                .map(date => monthlyData[date])
                                .filter(val => val !== undefined);
                            
                            if (yearValues.length > 0) {
                                // Create SVG line chart for monthly trend
                                const chartWidth = 180;
                                const chartHeight = 60;
                                const padding = { top: 8, right: 8, bottom: 15, left: 30 };
                                
                                const minVal = Math.min(...yearValues);
                                const maxVal = Math.max(...yearValues);
                                const range = maxVal - minVal || maxVal;
                                
                                // Calculate x and y positions for line chart
                                const pointCount = yearValues.length;
                                const xStep = (chartWidth - padding.left - padding.right) / (pointCount - 1 || 1);
                                const points = yearValues.map((val, i) => {
                                    const x = padding.left + (i * xStep);
                                    const y = chartHeight - padding.bottom - ((val - minVal) / range) * (chartHeight - padding.top - padding.bottom);
                                    return `${x},${y}`;
                                }).join(' ');
                                
                                monthlyDataHtml = `
                                    <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #ddd; width: 100%; overflow: hidden;">
                                        <div style="font-size: 10px; font-weight: 700; color: #333; margin-bottom: 4px;">${year} Monthly Trend</div>
                                        <svg width="100%" height="auto" viewBox="0 0 ${chartWidth} ${chartHeight}" preserveAspectRatio="xMidYMid meet" style="border: 1px solid #ddd; border-radius: 2px; background: #fafafa; max-width: 100%; max-height: 60px; display: block;">
                                            <!-- Y-axis -->
                                            <line x1="${padding.left}" y1="${padding.top}" x2="${padding.left}" y2="${chartHeight - padding.bottom}" stroke="#ddd" stroke-width="1"/>
                                            <!-- X-axis -->
                                            <line x1="${padding.left}" y1="${chartHeight - padding.bottom}" x2="${chartWidth - padding.right}" y2="${chartHeight - padding.bottom}" stroke="#ddd" stroke-width="1"/>
                                            <!-- Line chart -->
                                            <polyline points="${points}" fill="none" stroke="url(#gradientText)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                            <!-- Y-axis labels -->
                                            <text x="5" y="${chartHeight - padding.bottom + 3}" font-size="8" fill="#999" text-anchor="end">RM ${minVal.toFixed(0)}</text>
                                            <text x="5" y="${padding.top + 3}" font-size="8" fill="#999" text-anchor="end">RM ${maxVal.toFixed(0)}</text>
                                        </svg>
                                    </div>
                                `;
                            }
                        }
                    }
                    
                    tooltip.html(`
                        ${imageHtml}
                        <div class="tooltip-title">${getDenominationLabel(d.data.name)}</div>
                        <div class="tooltip-value">Circulating Value: RM ${d.value.toFixed(0)}</div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${percentage}%">
                                ${percentage.toFixed(1)}%
                            </div>
                        </div>
                        ${monthlyDataHtml}
                    `)
                    .style('opacity', 1);
                    
                    // Calculate position after content is rendered
                    setTimeout(() => {
                        const tooltipNode = tooltip.node();
                        const tooltipWidth = tooltipNode.offsetWidth;
                        const tooltipHeight = tooltipNode.offsetHeight;
                        const pos = getTooltipPosition(event.pageX, event.pageY, tooltipWidth, tooltipHeight);
                        tooltip.style('left', pos.left + 'px')
                            .style('top', pos.top + 'px');
                    }, 0);
                })
                .on('mousemove', function(event) {
                    const tooltip = d3.select('.hover-tooltip');
                    const tooltipNode = tooltip.node();
                    if (tooltipNode) {
                        const tooltipWidth = tooltipNode.offsetWidth;
                        const tooltipHeight = tooltipNode.offsetHeight;
                        const pos = getTooltipPosition(event.pageX, event.pageY, tooltipWidth, tooltipHeight);
                        tooltip.style('left', pos.left + 'px')
                            .style('top', pos.top + 'px');
                    }
                })
                .on('mouseleave', function(event, d) {
                    d3.select('.hover-tooltip').style('opacity', 0);
                });
            
            hoverers.append('title')
                .text(d => `${d.data.name}\nValue: RM ${d.value.toFixed(0)}`);
        }

        // Toggle button functionality - now handled in initLayout
        // Bubble view removed from this version
    </script>
</body>
</html>
